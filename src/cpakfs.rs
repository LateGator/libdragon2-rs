use core::{ffi::CStr, marker::PhantomData};

use crate::{
    io,
    joypad::{Joypads, Port},
    sys::cpakfs::*,
    ucstr::{UCStr, UCStringArray},
};

#[doc = "Usage statistics for a Controller Pak\n\n This structure is returned by `cpakfs_get_stats` and contains the usage\n statistics for a controller pak."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stats {
    #[doc = "Total number of pages in the controller pak"]
    pub pages_total: u32,
    #[doc = "Number of pages used in the controller pak"]
    pub pages_used: u32,
    #[doc = "Total number of notes in the controller pak"]
    pub notes_total: u32,
    #[doc = "Number of notes used in the controller pak"]
    pub notes_used: u32,
    #[doc = "Number of banks in the controller pak (as recorded in the filesystem)"]
    pub num_banks: u32,
}

#[doc = "Cpak filesystem issue levels"]
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub enum IssueLevel {
    #[doc = " The reported issue does not prevent a filesystem from mounting or otherwise working.\n  It's just advisory.\n  Example: a backup copy isn't synchronized with the main copy; a reserved sector\n  isn't correctly marked as such, etc."]
    Info = cpakfs_issue_level_t_CPAKFS_LEVEL_INFO as _,
    #[doc = " The issue can prevent correct interpretation of the filesystem, but can be\n recovered automatically."]
    Warning = cpakfs_issue_level_t_CPAKFS_LEVEL_WARNING as _,
    #[doc = " The issue is critical; integrity of the filesystem is potentially compromised\n and data may be lost after recovery."]
    Error = cpakfs_issue_level_t_CPAKFS_LEVEL_ERROR as _,
}

#[doc = "Cpak filesystem issues"]
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub enum Issue {
    #[doc = "Cannot find an ID sector with correct checksum"]
    FSIDChecksumFailure = cpakfs_issue_t_CPAKFS_ISSUE_FSID_CHECKSUM_FAILURE as _,
    #[doc = "ID sector has a known-corrupted checksum generated by DexDrive"]
    FSIDDexDrive = cpakfs_issue_t_CPAKFS_ISSUE_FSID_DEXDRIVE as _,
    #[doc = "ID sector backup is corrupted (can be recovered from main)"]
    FSIDCorruptedBackup = cpakfs_issue_t_CPAKFS_ISSUE_FSID_CORRUPTED_BACKUP as _,
    #[doc = "Device ID is not valid; this is just advisory so it can be ignored"]
    FSIDWrongDeviceID = cpakfs_issue_t_CPAKFS_ISSUE_FSID_WRONG_DEVICE_ID as _,
    #[doc = "FAT page has invalid checksum"]
    FATChecksumFailure = cpakfs_issue_t_CPAKFS_ISSUE_FAT_CHECKSUM_FAILURE as _,
    #[doc = "FAT page has unsynchronized copies"]
    FATUnsychronized = cpakfs_issue_t_CPAKFS_ISSUE_FAT_UNSYNCHRONIZED as _,
    #[doc = "Reserved page has invalid FAT entry"]
    FATInvalidReserved = cpakfs_issue_t_CPAKFS_ISSUE_FAT_INVALID_RESERVED as _,
    #[doc = "Invalid FAT entry"]
    FATInvalidEntry = cpakfs_issue_t_CPAKFS_ISSUE_FAT_INVALID_ENTRY as _,
    #[doc = "FAT entry has invalid bank number"]
    FATInvalidBank = cpakfs_issue_t_CPAKFS_ISSUE_FAT_INVALID_BANK as _,
    #[doc = "Note has invalid gamecode"]
    NoteInvalidGameCode = cpakfs_issue_t_CPAKFS_ISSUE_NOTE_INVALID_GAMECODE as _,
    #[doc = "Note has invalid publisher code"]
    NoteInvalidPubCode = cpakfs_issue_t_CPAKFS_ISSUE_NOTE_INVALID_PUBCODE as _,
    #[doc = "Note has invalid first page"]
    NoteInvalidFirstPage = cpakfs_issue_t_CPAKFS_ISSUE_NOTE_INVALID_FIRST_PAGE as _,
    #[doc = "Note has invalid characters in filename or extension"]
    NoteInvalidCharset = cpakfs_issue_t_CPAKFS_ISSUE_NOTE_INVALID_CHARSET as _,
    #[doc = "Note is not correctly marked as occupied"]
    NoteNotOccupied = cpakfs_issue_t_CPAKFS_ISSUE_NOTE_NOT_OCCUPTED as _,
    #[doc = "Chain has infinite loop"]
    ChainInfiniteLoop = cpakfs_issue_t_CPAKFS_ISSUE_CHAIN_INFINITE_LOOP as _,
    #[doc = "Chain does not end with terminator"]
    ChainNoTerminator = cpakfs_issue_t_CPAKFS_ISSUE_CHAIN_NO_TERMINATOR as _,
    #[doc = "Chain collides with another chain"]
    ChainCollision = cpakfs_issue_t_CPAKFS_ISSUE_CHAIN_COLLISION as _,
    #[doc = "Orphaned chain found"]
    ChainOrphaned = cpakfs_issue_t_CPAKFS_ISSUE_CHAIN_ORPHANED as _,
}

#[doc = "Cpakfs path components\n\n A file path on the cpak filesystem is composed of four components:\n\n -  Game code: this would normally match the game ID in the ROM header, so\n    it is a 4-character string made of uppercase letters and digits. In some\n    cases (eg: Datel Gameshark), it is made of non-printable characters.\n -  Publisher code: this is a 2-character string that identifies the publisher\n    of the game. It was a global registry assigned by Nintendo. Like the game\n    code, this is normally just uppercase letters and digits.\n -  Filename: this is a character string in a custom codepage. The codepage\n    is a subset of ASCII, notably excluding lowercase letters and common\n    characters like the underscore, but including some Katana characters.\n    Notice also that the string might contain embedded NULs. The actual\n    filename length is determined by the position of the last non-zero byte.\n -  Extension: an optional 4-character string to further identify the file.\n    Sometimes games use the same filename for all saves and just put an\n    index in the extension, like \"SAVE.0\", \"SAVE.1\", etc. The actual\n    extension length is determined by the position of the last non-zero byte.\n\n Cpakfs in libdragon offers a simplified interface to manipulate paths\n using what it called a \"full name\". A full name is a UTF-8 string that\n contains all the components, composed as follows:\n\n    GAME.PU-filename.ext\n\n The full name is also the string that you can use when manipulating notes\n via the filesystem interface (eg: fopen, `dir_walk`, etc).\n\n You can use `cpakfs_path_parse` and `cpakfs_path_format` to convert from\n and to the UTF-8 full name and the `cpakfs_path_t` structure. Normally,\n users of cpakfs will only need to use the full name, but some advanced\n uses might require accessing the individual components."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Path {
    #[doc = "Game code (4 chars, normally ASCII)"]
    pub gamecode: [u8; 4usize],
    #[doc = "Publisher code (2 chars, normally ASCII)"]
    pub pubcode: [u8; 2usize],
    #[doc = "Filename in N64 codepage (zero-padded)"]
    pub filename: [u8; 16usize],
    #[doc = "Extension in N64 codepage (zero-padded)"]
    pub ext: [u8; 4usize],
}

#[doc = "[`path_parse`] result codes"]
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub enum ParseError {
    #[doc = "Game code too short in the path"]
    GameCodeTooShort = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_GAMECODE_TOO_SHORT,
    #[doc = "Game code too long in the path"]
    GameCodeTooLong = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_GAMECODE_TOO_LONG,
    #[doc = "Invalid game code character"]
    GameCodeInvalid = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_GAMECODE_CHAR,
    #[doc = "Publisher code too short in the path"]
    PubCodeTooShort = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_PUBCODE_TOO_SHORT,
    #[doc = "Publisher code too long in the path"]
    PubCodeTooLong = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_PUBCODE_TOO_LONG,
    #[doc = "Invalid publisher code character in the path"]
    PubCodeInvalid = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_PUBCODE_CHAR,
    #[doc = "Filename too short (empty) in the path"]
    FileNameTooShort = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_FILENAME_TOO_SHORT,
    #[doc = "Filename too long in the path"]
    FileNameTooLong = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_FILENAME_TOO_LONG,
    #[doc = "Invalid filename character in the path"]
    FileNameInvalid = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_FILENAME_CHAR,
    #[doc = "Extension too long in the path"]
    ExtensionTooLong = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_EXTENSION_TOO_LONG,
    #[doc = "Invalid extension character in the path"]
    ExtensionInvalid = cpakfs_parse_err_t_CPAKFS_PARSE_ERR_EXTENSION_CHAR,
}

#[repr(transparent)]
#[derive(Debug)]
pub struct CPakFS<'s>(Port, PhantomData<&'s Joypads>);

impl Path {
    #[doc = "Parse a cpakfs fullpath into its components\n\n This function parses a full path in the format \"GAMECODE.PU-filename.ext\"\n and extracts the game code, publisher code, filename, and extension into\n the provided `cpakfs_path_t` structure.\n\n Parsing a path might fail if the input full path is not in the expected\n format (eg: too long components), or if the filename or extension contains\n unsupported characters. If @p error_pos is provided, it will be set to point\n to the first character that caused the error.\n\n @param utf8_fullname         Input full path to parse (UTF-8 string)\n @param path                  Output path structure to populate\n @param error_pos             Optional output parameter to indicate the position\n                              of the first error in the input string, if parsing fails.\n @result 0 on success, or a negative value indicating the type of error. See\n         `cpakfs_parse_err_t` for details."]
    pub fn parse(fullname: &UCStr) -> core::result::Result<Self, (ParseError, usize)> {
        unsafe {
            let mut path = core::mem::MaybeUninit::uninit();
            let mut errorpos = core::mem::MaybeUninit::uninit();
            let err = cpakfs_path_parse(
                fullname.as_ptr() as _,
                path.as_mut_ptr(),
                errorpos.as_mut_ptr(),
            );
            if err == cpakfs_parse_err_t_CPAKFS_PARSE_OK {
                Ok(core::mem::transmute(path.assume_init()))
            } else {
                Err((core::mem::transmute(err), errorpos.assume_init() as _))
            }
        }
    }
    #[doc = "Format a cpakfs path structure into a full path string\n\n This function will always succeed, as it will find a way to format any\n combination of game code, publisher code, filename, and extension, including\n invalid byte sequences according to the expected codepages and rules, falling\n back to hex encoding if necessary.\n\n For instance, if the gamecode is not a valid ASCII string but a random sequence\n of bytes like eg: `\"\\x04\\x05\\x06\\x07\"`, the function will format it as\n `\"04050607.PU-filename.ext\"`.\n\n So it is guaranteed that any input path structure can be formatted into a valid\n UTF-8 string as full name, and that the resulting string will always be\n parsable back to the same path structure using `cpakfs_path_parse`.\n\n @param path                  Input path structure to format\n @param utf8_fullname         Output buffer to receive the formatted full path (UTF-8 string)\n @param buflen                Size of the output buffer (including space for null terminator)\n @return int                  0 on success, -1 if the buffer was too small"]
    pub fn format<const N: usize>(&self) -> Option<UCStringArray<N>> {
        unsafe {
            let mut fullname = core::mem::MaybeUninit::<[u8; N]>::uninit();
            let ret =
                cpakfs_path_format(&self as *const _ as _, fullname.as_mut_ptr() as _, N as _);
            if ret == 0 {
                let fullname = fullname.assume_init();
                let len = CStr::from_bytes_until_nul(&fullname)
                    .unwrap_unchecked()
                    .to_bytes()
                    .len();
                Some(UCStringArray::from_raw_unchecked(fullname, len as _))
            } else {
                None
            }
        }
    }
}

pub trait CPakExt: crate::sealed::Sealed {
    #[doc = "Mount the controller pak as filesystem\n\n This function mounts the contents of a controller pak as a virtual\n filesystem, with the specified prefix. After this function successfully\n return, it is possible to access the notes in the cpak using standard\n C functions like fopen.\n\n \\code{.c}\n      if (cpak_mount(JOYPAD_PORT_1, \"cpak1:/\") < 0) {\n         // handle errors, by inspecting errno [...]\n         return;\n      }\n\n      // Read the following note:\n      //   Game code: NAFJ\n      //   Publisher code: 01\n      //   Filename: DOUBUTSUNOMORI\n      //   File extension: A\n      FILE *f = fopen(\"cpak1:/NAFJ.01/DOUBUTSUNOMORI.A\");\n \\endcode\n\n The virtual filesystem structure is as follows:\n   * Root directory contains no files, only subdirectories. The name of the\n     subdirectories is a 4.2 ASCII string that encode the game code and\n     publisher code (eg: \"NSME.01\")\n   * Within each subdirectory, you can find one or multiple files that are\n     the notes found in the cpak. The filenames are UTF-8 strings that must\n     adhere to the special cpak charset.\n   * Empty directories do not exist.\n\n In case of error while mounting the filesystem, errno is set as follows:\n\n  * EIO: Input/output error on the wire. The serial connection is faulty,\n    so either the cable is damaged or the cpak is electrically unstable.\n  * ENXIO: The controller pak or the whole joypad has been abruptly disconnected\n    during the operation.\n  * ENODEV: the controller pak appears not to contain a valid filesystem, or\n    it was corrupted. Use `cpakfs_fsck` to try recovering the contents.\n\n @param port              Cpak to mount, identified by the joypad port\n @param prefix            Filesystem prefix to use for mounting. Suggested\n                          name is \"cpakN:/\" where \"N\" is the controller\n                          port (1..4).\n @return 0 if success, negative value in case of error (and errno is set)"]
    #[inline]
    fn cpak_mount<'j>(&'j self, port: Port, prefix: &CStr) -> io::Result<CPakFS<'j>> {
        io::Error::catch_negative(unsafe { cpakfs_mount(port as _, prefix.as_ptr()) })?;
        Ok(CPakFS(port, PhantomData))
    }
    #[doc = "Read the serial number of a controller pak\n\n This function reads the 20-byte serial number of a controller pak.\n This is a unique identifier that can be used to distinguish between\n different controller paks. It is normally generated with random data\n when the controller pak is formatted, so it does not contain printable\n characters.\n\n @param port          The controller pak to read the serial from\n @param serial        The buffer where to store the serial number (24 bytes)\n @return 0            if the serial was successfully read\n @return negative     if an error occurred (eg: no cpak on the specified port),\n                      and errno is set accordingly."]
    #[inline]
    fn cpak_serial(&self, port: Port) -> io::Result<[u8; 20]> {
        unsafe {
            let mut serial = core::mem::MaybeUninit::<[u8; 20]>::uninit();
            io::Error::catch_negative(cpakfs_get_serial(port as _, serial.as_mut_ptr() as _))?;
            Ok(serial.assume_init())
        }
    }
    #[doc = "Read the usage state of a controller pak\n\n @note The filesystem must be mounted before calling this function.\n\n @param port          The controller pak to read the usage state from\n @param stats         The structure where to store the usage statistics\n @return 0            if the serial was successfully read\n @return negative     if an error occurred (eg: no cpak on the specified port),\n                      and errno is set accordingly."]
    #[inline]
    fn cpak_stats(&self, port: Port) -> io::Result<Stats> {
        unsafe {
            let mut stats = core::mem::MaybeUninit::uninit();
            io::Error::catch_negative(cpakfs_get_stats(port as _, stats.as_mut_ptr()))?;
            Ok(core::mem::transmute(stats.assume_init()))
        }
    }
    #[doc = "Check the integrity of a controller pak\n\n This function checks the integrity of a controller pak filesystem, and\n optionally tries also to repair it if unreadable, and recover as much as\n possible.\n\n Found issues can be reported via the report callback, which is called\n for each issue found.\n\n The return value will report the number of issues found whose level is at least\n CPAKFS_LEVEL_WARNING. In fact, issues of kind CPAKFS_LEVEL_INFO, while fixable,\n do not impact filesystem integrity in any way (for instance, a backup copy\n of some metadata might be corrupted, but the main copy is still valid).\n\n @param port          The controller pak to check the integrity of\n @param fix_errors    Whether to fix the errors found\n @param report        Optional callback to report issues found during the check\n @param report_ctx    Optional context to pass to the report callback\n @return positive     Number of issues found (and possibly fixed if @p fix_errors is true).\n @return 0            No issues found.\n @return negative     If a physical error occurred (eg: no cpak on the specified port),\n                      and errno will be set accordingly."]
    fn cpak_fsck(&self, port: Port, fix_errors: bool) -> io::Result<u32> {
        let count = unsafe { cpakfs_fsck(port as _, fix_errors, None, core::ptr::null_mut()) };
        if count >= 0 {
            Ok(count as u32)
        } else {
            Err(io::Error::catch_negative(count).unwrap_err())
        }
    }
    #[doc = "Format a controller pak\n\n This function formats a controller pak, resetting to a pristine, valid\n empty state. By default, the function only erases the filesystem\n metadata but does not purge content from all the pages. This is OK for\n most use cases.\n\n If @p erase is true, all pages are written with zeros, effectively erasing\n all the content from the controller pak.\n\n @param port      The controller pak to format\n @param erase     Whether to erase all content or just the metadata\n @return int      0 on success, negative on error"]
    fn cpak_format(&self, port: Port, erase: bool) -> io::Result<()> {
        io::Error::catch_negative(unsafe { cpakfs_format(port as _, erase) })?;
        Ok(())
    }
}

impl CPakExt for Joypads {}

impl<'s> crate::Undroppable for &mut CPakFS<'s> {
    const ERROR: &'static str = "Finish the controller pak operations with CPakFS::unmount";
}

impl<'s> Drop for CPakFS<'s> {
    #[inline]
    fn drop(&mut self) {
        let _ = crate::DropBomb::new(self);
    }
}

impl<'s> CPakFS<'s> {
    #[doc = "Unmount the controller pak filesystem\n\n This function unmounts the controller pak filesystem, waiting for all\n pending operations to complete.\n\n @param port              The controller pak to unmount\n @return 0 if success, negative value in case of error (and errno is set)"]
    #[inline]
    pub fn unmount(self) -> io::Result<()> {
        let port = core::mem::ManuallyDrop::new(self).0;
        io::Error::catch_negative(unsafe { cpakfs_unmount(port as _) })?;
        Ok(())
    }
}
